<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>Dynamic movement and collision handling - Dennis Zethof</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="http://localhost:8000/projects-flying-dots.html">


        <meta name="author" content="Dennis Zethof" />
        <meta name="description" content="This project is part of a larger project, which involves creating an alive version of a drawing I saw. But to be able to achieve this, the dots involved have to be able to detect eachother and handle collisions accordingly. This turned out to be quite challenging. Although this version …" />

        <meta property="og:site_name" content="Dennis Zethof" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="Dynamic movement and collision handling"/>
        <meta property="og:url" content="http://localhost:8000/projects-flying-dots.html"/>
        <meta property="og:description" content="This project is part of a larger project, which involves creating an alive version of a drawing I saw. But to be able to achieve this, the dots involved have to be able to detect eachother and handle collisions accordingly. This turned out to be quite challenging. Although this version …"/>
        <meta property="article:published_time" content="2019-02-14" />
            <meta property="article:section" content="projects" />
            <meta property="article:author" content="Dennis Zethof" />



    <!-- Bootstrap -->
        <link rel="stylesheet" href="http://localhost:8000/theme/css/bootstrap.flatly.min.css" type="text/css"/>
    <link href="http://localhost:8000/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="http://localhost:8000/theme/css/pygments/native.css" rel="stylesheet">
    <link rel="stylesheet" href="http://localhost:8000/theme/css/style.css" type="text/css"/>
        <link href="http://localhost:8000/css/custom.css" rel="stylesheet">



    <!-- Google Analytics Universal -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-135283341-1', 'auto');
        ga('send', 'pageview');
    </script>
    <!-- End Google Analytics Universal Code -->
</head>
<body>


<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://localhost:8000/" class="navbar-brand">
Dennis Zethof            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                    <li><a href="/pelican_ceilings/category/posts.html">Posts</a></li>
                    <li><a href="/pelican_ceilings/category/projects.html">Projects</a></li>
                    <li><a href="/pelican_ceilings/pages/publications.html">Publications</a></li>
                    <li><a href="/pelican_ceilings/pages/About.html">About</a></li>




            </ul>
            <ul class="nav navbar-nav navbar-right">
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->


<!-- Banner -->
<!-- End Banner -->

<div></div>


<!-- Content Container -->
<div class="container">
    <div class="row">
        <div class="col-sm-9">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="http://localhost:8000/projects-flying-dots.html"
                       rel="bookmark"
                       title="Permalink to Dynamic movement and collision handling">
                        Dynamic movement and collision handling
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2019-02-14T00:00:00+01:00"> Thu 14 February 2019</time>
    </span>





    
</footer><!-- /.post-info -->                    </div>
                </div>
                <div class="container-for-dots">
    <div class="ref_point"></div>
</div>

<p>This project is part of a larger project, which involves creating an alive version of a drawing I saw. But to be able to achieve this, the dots involved have to be able to detect eachother and handle collisions accordingly. This turned out to be quite challenging.</p>
<p>Although this version is not finished, it is fully functioning. As explained in the repository one could even make adjustments in the options to see what type of effect this will have the dots behavior and their interaction with eachother.</p>
<p>Some challenges in this projects were:</p>
<ul>
<li>maths, getting a grip on calculating new paths after collisions,</li>
<li>finding decent ways of keeping track of situations (how does this collision effect future collisions),</li>
<li>discovering the profileris in both Chrome and Firefox to help create more efficient code,</li>
<li>and discovering the Firefox profiler is more informative/less buggy,</li>
<li>finding out that modifying arrays takes <em>waaaaay</em> more cpu power than collision calculations do
.</li>
</ul>
<p><br>
To visit the site click <a href="https://dzet.github.io">here</a>.
The repository can be found <a href="https://github.com/DZet/flying-dots">here</a>.</p>
<style>

    #together {
        max-width: 500px;
        height: auto;
        margin: 0 auto;
        box-sizing: content-box;
    }

    #circle {
        width: 500px;
        height: 500px;

        position: relative;
        border: 3px solid black;

        box-sizing: content-box;
    }

</style>

<script type="text/javascript">

    // globals

    // set options/constants
    var main_loop_interval = 35             // in milliseconds
    var dots_per_second = 0.5
    var circle_resolution = 20              // 2pi/circle_res
    var starting_point = { x: 45, y: 45 }

    var settings_decimals_increment = 9
    var settings_decimals_calculations = 9
    var settings_maximum_dots = 100 

    var section_size = { x: 20, y: 20 }     // in pixels
    var dots = []                           // for debug purposes defined as global
    // var grid_positions = []              // for debug purposes defined as global
    var collision_storage = []
    var outer_boundaries = { 'x':[], 'y': [] }

    var demo_mode = true
    var debug_main_loop_counter = 0
    var whilecounter = 0    
    var debug = false                       // general debug mode
    var debug_coll = false                  // debug mode for setting up collision det
    var debug_check_list = []
    var debug_timer_tracker = 0
    var debug_timer = 4.50                  // seconds
    var debug_timer_steps = 100             // miliseconds
    var debug_specific = false 
    var debug_showstoppers = false
    var debug_count_dots = true
    var debug_add_numbers = false

    var debug_m2 = true


    window.onload = function() { 
        var loops_before_new_dot = Math.round(dots_per_second/(main_loop_interval/1000))

        if (debug) {

            debug_test_find_collision()
        }

        var loops_since_new_dot = loops_before_new_dot-1
        var new_dot_id = 0
        var border_objects = []
        var grid_positions = []
        var grid_border_positions = []
        get_set_border_objects(border_objects)
        set_outer_boundaries(outer_boundaries, border_objects)

        set_border_positions(grid_border_positions, border_objects)
        grid_sort_positions(grid_border_positions)

        var main_loop = setInterval(function() {

            if (debug) {

                debug_main_loop_counter++
            }

            loops_since_new_dot++

            if (loops_since_new_dot==loops_before_new_dot
             && dots.length<settings_maximum_dots) {

                new_dot_id++
                var new_dot = new Dot(new_dot_id, dots.length)
                dots.push(new_dot)
                loops_since_new_dot = 0
            }

            if (debug_count_dots) {

                var counter_dots = document.getElementById('counter_dots')
                counter_dots.innerHTML = dots.length
            }

            for (var d=0;d<dots.length;d++) {

                dots[d].determine_next_coords()
                dots[d].manage_sections_setting()
            }

            grid_add_border_positions(grid_positions, grid_border_positions)
            grid_positions = weave_dots_with_grid(grid_positions, dots)

            find_collisions(collision_storage, grid_positions)
            sort_collision_time(collision_storage)

            while (collision_storage.length>0) {

                grid_positions = manage_collision(grid_positions, collision_storage)
            }

            for(var d=0; d<dots.length; d++) {

                dots[d].set_coords()
                dots[d].move()
                dots[d].increment = 0
            }

            if (debug_showstoppers) {

                debug_test_overlap_all_dots(dots) 
            }

            whilecounter = 0
            grid_positions = []
            collision_storage = []

        }, main_loop_interval)

    }

    function manage_collision(grid_positions, collision_storage) {

        var info = get_next_collision_info(collision_storage)
        process_collision(info)
        process_objects(info) 

        grid_positions = process_grid_positions(grid_positions, info)

        //~no grid_positions adjustment:
        process_collision_storage(collision_storage, grid_positions, info)

        if (debug) {

            debug_check_overlap(info.obj_1, info.obj_2)
        }

        return grid_positions
    }

    function process_collision_storage(collision_storage, grid_positions, info) {

        clean_collision_storage(collision_storage, info)
        find_collisions(collision_storage, grid_positions, info)
        sort_collision_time(collision_storage)

        return
    }

    function process_objects(info) {

        do_section_setting(info.obj_1)
        do_section_setting(info.obj_2)
        info["redo_list"] = create_redo_list(info.obj_1, info.obj_2)

        return
    }

    function process_grid_positions(grid_positions, info) {

        grid_positions = remove_old_grid_positions(grid_positions, [info.obj_1, info.obj_2])

        // make sure only dots are entered in grid_positions
        var dots_to_add = []
        select_dots(dots_to_add, info)

        var sorted_grid_spots_to_add = get_sort_new_grid_spots(dots_to_add)
        grid_positions = weave_grids_together(grid_positions, sorted_grid_spots_to_add)

        return grid_positions 
    }

    function select_dots(dots_to_add, info) {

        if (info.obj_1 instanceof Dot) {

            dots_to_add.push(info.obj_1)
        }

        if (info.obj_2 instanceof Dot) {

            dots_to_add.push(info.obj_2)
        }

        return
    }

    function do_section_setting(obj) {

        if (obj instanceof Dot) {

            obj.manage_sections_setting()
        }

        return
    }

    function process_collision(info) {
        // this is a 1-2 between coords_theory and
        // next_coords_theory. This collision has been set
        // as next one so next coords will be used icw
        // the incr to set the new coord. The new course
        // will then be determined, incl. the tracking
        // of that collision, and then, icw the new course,
        // a new next coord will be determined icw the
        // remaining incr value.
        var [obj_1, obj_2, incr] = [info.obj_1, info.obj_2, info.incr]

        set_coll_coordinates(obj_1, incr)
        set_coll_coordinates(obj_2, incr)
        handle_object_movement(obj_1)
        handle_object_movement(obj_2)

        choose_new_course_calculation(obj_1, obj_2, incr) 

        set_next_coordinates(obj_1)     
        set_next_coordinates(obj_2)     

        return
    }

    function get_next_collision_info(collision_storage) {

        var info = collision_storage[0]
        info.redo_mode = true   

        return info 
    }

    function create_redo_list(obj_1, obj_2) {
        var redo_list = []

        if (obj_1 instanceof Dot) {

            var first = obj_1
            var second = obj_2

        } else if (obj_2 instanceof Dot) {

            var first = obj_2
            var second = undefined

        } else {

            // error..
            debugger
        }

        for (var gp=0;gp<first.grid_spots.length;gp++) {

            redo_list.push(first.grid_spots[gp])
        }

        if (second instanceof Dot) {

            var found = false

            for (var gp=0;gp<second.grid_spots.length;gp++) {

                found = false

                for (var rl=0;rl<redo_list.length;rl++) {

                    if (second.grid_spots[gp]["x"]==redo_list[rl]["x"] 
                     && second.grid_spots[gp]["y"]==redo_list[rl]["y"]) {

                        found = true
                        break
                    }
                }   

                if (!found) {

                    redo_list.push(second.grid_spots[gp])
                }
            }
        }

        return redo_list
    }

    function clean_collision_storage(collision_storage, info) {
        var cl = 0

        while (cl<collision_storage.length) {

            var cl_st = collision_storage[cl]

            if (cl_st.obj_1 instanceof Dot && cl_st.obj_2 instanceof Dot) {

                if (cl_st.obj_1===info.obj_1 || cl_st.obj_1===info.obj_2) { 

                    collision_storage.splice(cl, 1)
                    continue

                } else if (cl_st.obj_2===info.obj_1 || cl_st.obj_2===info.obj_2) {

                    collision_storage.splice(cl, 1)
                    continue
                }   

            } else if (!(cl_st.obj_1 instanceof Dot)) {

                if (cl_st.obj_2===info.obj_1 || cl_st.obj_2===info.obj_2) {

                    collision_storage.splice(cl, 1)
                    continue
                }   

            } else if (!(cl_st.obj_2 instanceof Dot)) {

                if (cl_st.obj_1===info.obj_1 || cl_st.obj_1===info.obj_2) {

                    collision_storage.splice(cl, 1)
                    continue
                }
            }

            cl++    
        }

        return
    }

    function set_coll_coordinates(obj, incr) {

        if (obj instanceof Dot) {

            obj.coords_theory.x = round_calc_general(obj.coords_theory.x + 
                                    (obj.course.x * (incr-obj.increment)))
            obj.coords_theory.y = round_calc_general(obj.coords_theory.y + 
                                    (obj.course.y * (incr-obj.increment))) 
            obj.coords.x = Math.round(obj.coords_theory.x)
            obj.coords.y = Math.round(obj.coords_theory.y)
            obj.increment = incr
        }

        return  
    }

    function check_round_incr(incr) {

        return get_rounded_number(incr, settings_decimals_increment)
    }

    function round_calc_general(value) {

        return get_rounded_number(value, settings_decimals_calculations)
    }

    function get_rounded_number(value, decimals) {

        if (value>=1000000000000) {
            console.log("Not yet implemented: error will occur, number was " +
                        "larger than possible for current implementation of " +
                        "determining decimals.\n" +
                        "Also triggers on Infinity, which can be generated " +
                        "when dividing by 0. \n" +
                        "Calling console.trace() now: ")
            // console.trace()
            // debugger
        }

        // Alternatively, bitshift could be used.
        return Number(Math.round(value*10**(decimals))/10**(decimals))
    }


    function handle_object_movement(obj) {

        if (obj instanceof Dot) {

            obj.move()
        }

        return
    }

    function set_next_coordinates(obj) {

        if (obj instanceof Dot) {

            obj.next_coords_theory["x"] = round_calc_general(obj.coords_theory["x"] + 
                                            (obj.course["x"]*(1-obj.increment)))
            obj.next_coords_theory["y"] = round_calc_general(obj.coords_theory["y"] + 
                                            (obj.course["y"]*(1-obj.increment)))
        }

        return
    }

    function grid_add_border_positions(grid_positions, grid_border_positions) {

        for (var gb=0;gb<grid_border_positions.length;gb++) {

            grid_positions.push(grid_border_positions[gb])
        }

        return 
    }

    function grid_add_dot_positions(grid_positions, objects_to_add) {

        for (var d=0;d<objects_to_add.length;d++) {

            for (var gs=0;gs<objects_to_add[d].grid_spots.length;gs++) {

                grid_positions.push(objects_to_add[d].grid_spots[gs])
            }
        }

        return
    }

    function get_sort_new_grid_spots(dots_to_add) {

        if (dots_to_add.length==2) {

            return weave_grids_together(dots_to_add[0].grid_spots, dots_to_add[1].grid_spots)
        }

        return dots_to_add[0].grid_spots
    }

    function remove_old_grid_positions(grid_positions, objects) {
        // - Cannot read grid_spots here, since by this time
        //   they have already been replaced with the new ones.
        //   Which might be a good reason to put this 
        //   method a littlebit earlier in the process.
        // - You would still have to search and remove, but
        //   not adjust the array length afterwards. 
        //      - but adjusting of length doesn't seem to
        //        cost that much time.
        // - grid_positions can hold both dots and lines

        var new_grid_positions = new Array(grid_positions.length)
        var relevant_objects = get_relevant_objects(objects)

        var found
        var amount_found = 0

        for (var gp=0;gp<grid_positions.length;gp++) {

            found = false

            for (var ro=0;ro<relevant_objects.length;ro++) {

                if (grid_positions[gp].obj===relevant_objects[ro]) {

                    found = true
                    break
                }
            }

            if (!found) {

                new_grid_positions[amount_found] = grid_positions[gp]
                amount_found++
            }
        }

        new_grid_positions.length = amount_found

        return new_grid_positions
    }

    function get_relevant_objects(objects) {                

        var relevant_objects = []

        for (var ob=0;ob<objects.length;ob++) {

            if (objects[ob] instanceof Dot) {

                relevant_objects.push(objects[ob])
            }
        }

        return relevant_objects
    }

    function find_collisions(collision_storage, grid_positions, redo_info={ redo_mode: false }) {

        var checked_this_round = []

        if (redo_info['redo_mode']) {

            var hash_package = create_redo_list_hash(redo_info['redo_list'])
        }

        for (var gp=0;gp<grid_positions.length-1;gp++) {

            if (redo_info['redo_mode']) {

                var redo_position = check_redo_position(grid_positions[gp], hash_package)
            }

            // find a double
            if (grid_positions[gp]['x']==grid_positions[gp+1]['x']
             && grid_positions[gp]['y']==grid_positions[gp+1]['y']) {

                var store_section = { x:                grid_positions[gp]['x'],
                                      y:                grid_positions[gp]['y'],
                                      objects_present: [grid_positions[gp]['obj'],
                                                        grid_positions[gp+1]['obj'],
                                                        ],
                                     }

                var grid_pos_different = find_all_other_doubles(store_section, grid_positions, gp+2)
                gp = grid_pos_different - 1

                if (redo_info['redo_mode']) {

                    // for redo_mode only have to finish the look if
                    // the grid_positions have to be reexamined
                    if (!redo_position) {

                        continue
                    }
                }

                check_section(store_section, checked_this_round, collision_storage, redo_info)
            }
        }

        return
    }

    function create_redo_list_hash(redo_list) {
        // - need min and max to prevent list from
        //   becoming too big

        //~ could set this upon creation of
        //  sections. (determine_all_sections)
        var mm_x = find_min_max(redo_list, 'x')
        var mm_y = find_min_max(redo_list, 'y')

        // 0 also counts, so for max's +1 to
        // determine maximum length array
        var length_x = (mm_x[1] + 1) - mm_x[0]
        var length_y = (mm_y[1] + 1) - mm_y[0]

        // - The hashing is not needed, since the
        //   redo_list is always a square, so
        //   max and min is enough.
        //      (turning it off seems to give 
        //       about 1% less)
        // - However, this may change in the
        //   future, what if the area is a circle?
        // - So we keep the table.
        var hash = new Array(length_x)

        for (var h=0; h<hash.length; h++) {

            hash[h] = new Array(length_y)
        }

        for (var rd=0;rd<redo_list.length;rd++) {

            hash[ redo_list[rd]['x'] - mm_x[0] ][ redo_list[rd]['y'] - mm_y[0] ] = true
        }

        var hash_package = { 'table': hash, 
                             'min_x':  mm_x[0], 
                             'min_y':  mm_y[0], 
                             'length_x': length_x,
                             'length_y': length_y,
                            }

        return hash_package
    }

    function find_min_max(redo_list, axis) {
        var max = -Infinity
        var min = Infinity

        for (var rl=0;rl<redo_list.length;rl++) {

            if (redo_list[rl][axis] < min) {

                min = redo_list[rl][axis]
            }

            if (redo_list[rl][axis] > max) {

                max = redo_list[rl][axis]
            }
        }

        return [min, max]
    }

    function check_redo_position(grid_pos, hash_p) {

        var pos_x = grid_pos['x'] - hash_p.min_x
        var pos_y = grid_pos['y'] - hash_p.min_y

        if (pos_x < 0) {

            return false

        } else if (pos_y < 0) {

            return false

        } else if (pos_x >= hash_p.length_x) {

            return false

        } else if (pos_y >= hash_p.length_y) {

            return false
        }

        var hr = hash_p.table[ pos_x ][ pos_y ]

        return (hr==true)
    }

    function find_all_other_doubles(store_section, grid_positions, next) {

        for (var gp_2=next;gp_2<grid_positions.length;gp_2++) {

            if (grid_positions[gp_2]["x"]==store_section["x"] 
             && grid_positions[gp_2]["y"]==store_section["y"]) {

                store_section["objects_present"].push(grid_positions[gp_2]["obj"])
                continue
            }

            break
        }

        return gp_2
    }

    function check_section(store_section, checked_this_round, collision_storage, redo_info) {
        var obj_list = store_section["objects_present"]

        for (var dl=0;dl<obj_list.length-1;dl++) {

            if (redo_info["redo_mode"]) {

                var first_dot_unchanged = undefined
                var second_dot_unchanged = undefined

                if (obj_list[dl] == redo_info.obj_1) {

                    first_dot_unchanged = false

                } else if (obj_list[dl] == redo_info.obj_2) {

                    first_dot_unchanged = false

                } else {

                    first_dot_unchanged = true
                }
            }

            if (obj_list[dl].type=="line") {

                var first_dot_is_line = true

            } else {

                var first_dot_is_line = false
            }

            for (var dl_2=dl+1;dl_2<obj_list.length;dl_2++) {

                if (first_dot_is_line && obj_list[dl_2].type=="line") {

                    continue
                }

                // TODO: untested
                if (already_checked_this_grid_cycle(checked_this_round, obj_list[dl], obj_list[dl_2])) {

                   continue
                }      

                if (redo_info["redo_mode"]) {

                    if (obj_list[dl_2] == redo_info.obj_1) {

                        second_dot_unchanged = false 

                    } else if (obj_list[dl_2] == redo_info.obj_2) {

                        second_dot_unchanged = false 

                    } else {

                        second_dot_unchanged = true
                    }

                    if (first_dot_unchanged && second_dot_unchanged) {

                        continue
                    }   

                    if (obj_list[dl].increment==1 || obj_list[dl_2].increment==1) {

                        continue
                    }
                }

                var result = choose_collision_calculation(obj_list[dl], obj_list[dl_2])
                checked_this_round.push({obj_1: obj_list[dl], obj_2: obj_list[dl_2]})

                if (result.found) {

                    collision_storage.push(result.log)
                }
            }
        }

        return
    }

    function already_checked_this_grid_cycle(checked_this_round, obj_1, obj_2) {

        for (var c=0;c<checked_this_round.length;c++) {

            if (checked_this_round[c].obj_1===obj_1 
             || checked_this_round[c].obj_1===obj_2) {

                if (checked_this_round[c].obj_2===obj_1 
                 || checked_this_round[c].obj_2===obj_2) {

                    return true
                }
            }
        }

        return false
    }

    function choose_collision_calculation(obj_1, obj_2) {

        if (obj_1 instanceof Dot && obj_2 instanceof Dot) {

            var result = find_collision_dots_5(obj_1, obj_2)

        } else {

            var result = find_collision_border_2(obj_1, obj_2)
        }

        return result   
    }

    function find_collision_dots_5(dot_1, dot_2) {

        if (dot_1.increment>dot_2.increment) {

            var dot_temp = dot_1
            dot_1 = dot_2
            dot_2 = dot_temp
        }

        var incr_diff = (dot_2.increment - dot_1.increment)
        var dot_1_bump_x = (dot_1.course.x * incr_diff)
        var dot_1_bump_y = (dot_1.course.y * incr_diff)
        var dot_1_x = round_calc_general(dot_1.coords_theory.x + dot_1_bump_x)
        var dot_1_y = round_calc_general(dot_1.coords_theory.y + dot_1_bump_y)

        var k1a = (dot_1_x**2 + dot_2.coords_theory.x**2) 
        var k1b = (-2 * dot_1_x * dot_2.coords_theory.x)
        var k1 = (k1a + k1b)
        var w1 = (dot_1.course.x - dot_2.course.x)
        var q1a = (2 * dot_1_x * w1)
        var q1b = (2 * dot_2.coords_theory.x * w1)
        var q1 = round_calc_general(q1a - q1b)

        var k2a = (dot_1_y**2 + dot_2.coords_theory.y**2)
        var k2b = (-2 * dot_1_y * dot_2.coords_theory.y)
        var k2 = (k2a + k2b)
        var w2 = (dot_1.course.y - dot_2.course.y)
        var q2a = (2 * dot_1_y * w2) 
        var q2b = (2 * dot_2.coords_theory.y * w2)
        var q2 = round_calc_general(q2a - q2b)

        var c_sq = round_calc_general(( (dot_1.radius + dot_2.radius) )**2)

        var wt = (w1**2 + w2**2)
        var qt = (q1 + q2)
        var kt = (k1 + k2 - c_sq)

        // abc formula:
        var a = wt
        var b = qt
        var c = kt

        if (debug) {
            if (a==0) {
                // error...
                console.log("error: a==0")
                debugger
            }
        }

        // discriminant of kwadratic formula    
        var d = (b**2 - (4 * a * c))

        if (d<0) {

            return { found: false, log: undefined }
        }

        var d_sqrt = round_calc_general(d**(1/2))
        var a2 = 2 * a
        var pt_1 = check_round_incr((-b + d_sqrt) / a2) 
        var pt_2 = check_round_incr((-b - d_sqrt) / a2) 


        function check_validity(pt_1, pt_2, max_increment) {

            // means they would go in the wrong direction for
            // them to be in a collision. Most likely they were
            // just in a collision, OR there was just some
            // overlap due to rounding
            if (pt_1 < 0 || pt_2 < 0) {

                return [false, false]
            }

            var first_valid = second_valid = false

            // first part of if statement is important when two collisions 
            // takes place at the same increment    
            if (pt_1 >= 0 && pt_1 <= max_increment) {

                first_valid = true
            }

            if (pt_2 >= 0 && pt_2 <= max_increment) {

                second_valid = true
            }

            return [first_valid, second_valid]
        }

        var max_increment = check_round_incr(1-dot_2.increment) 
                                          // FUNCTION
        var [first_valid, second_valid] = check_validity(pt_1, pt_2, max_increment)

        if (first_valid && second_valid) {

            var pt = Math.min(pt_1, pt_2)

        } else if (first_valid) {

            var pt = pt_1

        } else if (second_valid) {

            var pt = pt_2

        } else {

            return {found: false, log: undefined}
        }

        var incr_total = check_round_incr(dot_2.increment + pt)
        var result = { found: true, 
                       log: { incr: incr_total,
                              obj_1: dot_1,
                              obj_2: dot_2,
                             }
                      }

        if (debug) {

            if (incr_total>1) {

                //error..
                debugger
            }
        }

        return result
    } 

    function find_collision_border_2(obj_1, obj_2) {
        var dot, border

        if (obj_1 instanceof Dot) {

            dot = obj_1
            border = obj_2  

        } else {

            dot = obj_2
            border = obj_1
        }

        var border_normal = {}
        border_normal.x = round_calc_general(border.end.y - border.start.y)
        border_normal.y = round_calc_general(border.end.x - border.start.x)

        border_normal.length = (border_normal.x**2 + border_normal.y**2)**(1/2)

        border_normal.unit_x = border_normal.x / border_normal.length
        border_normal.unit_y = border_normal.y / border_normal.length

        // projection of starting position
        var dot_origin_border_x = (dot.coords_theory.x - border.start.x)
        var dot_origin_border_y = (dot.coords_theory.y - border.start.y)
        var proj_starting_pos_a = (dot_origin_border_x * border_normal.unit_x) 
        var proj_starting_pos_b = (dot_origin_border_y * border_normal.unit_y)
        var proj_starting_pos = round_calc_general(proj_starting_pos_a + proj_starting_pos_b)

        var c = dot.radius

        if (proj_starting_pos < 0) {
            c = -c
        }

        var k1 = ((dot.coords_theory.x) * border_normal.unit_x) 
        var k2 = ((dot.coords_theory.y) * border_normal.unit_y) 
        var k3 = (-border.start.x * border_normal.unit_x)
        var k4 = (-border.start.y * border_normal.unit_y)
        var k = round_calc_general(k1 + k2 + k3 + k4)
        var u1 = (dot.course.x * border_normal.unit_x)
        var u2 = (dot.course.y * border_normal.unit_y)
        var u = round_calc_general(u1 + u2)

        // -This can create problems, division by u further
        // down, but also it means there is no collision.
        // -Happens more often when there is lower 
        // precision with rounding.
        if (u==0) {

            return { found: false, log: undefined }
        }

        function check_validity(pt, pt_after, max_increment) {
            // ~logic
            if (pt > pt_after) {

                return false
            }

            if (debug) {

                if (pt==pt_after) {

                    // error..?
                    debugger
                }
            }

            //pt < 0 = bad
            //pt_after< 0 = bad
            if (pt < 0 || pt_after < 0) {

                return false
            }

            //pt <= max_increment = good
            if (pt > max_increment) {

                return false
            }

            return true
        }

        var k_coll = (k - c)
        var k_after = (k + c)
        var pt = check_round_incr(-k_coll/u)
        var pt_after = check_round_incr(-k_after/u)

        var max_increment = check_round_incr(1-dot.increment)   

        if (!check_validity(pt, pt_after, max_increment)) {

            return { found: false, log: undefined }
        }

        var incr_total = check_round_incr(dot.increment + pt)
        var result = { found: true, 
                       log: { incr: incr_total,
                              obj_1: dot,
                              obj_2: border
                             }
                      }

        if (debug) {

            if (incr_total>1) {

                debugger
            }
        }
        return result
    } 

    function choose_new_course_calculation(obj_1, obj_2, incr) {

        if (obj_1 instanceof Dot && obj_2 instanceof Dot) {

            get_set_new_course_two_dots(obj_1, obj_2, incr) 
            return
        }

        get_set_course_border(obj_1, obj_2, incr)   

        return
    }

    function get_set_course_border(obj_1, obj_2, incr) {

        if (obj_1 instanceof Dot) {

            var dot = obj_1
            var border = obj_2

        } else {

            var dot = obj_2
            var border = obj_1
        }

        var d_x = dot.course.x * incr
        var d_y = dot.course.y * incr
        var angle_old = Math.atan2(d_y, d_x)

        if (border.side=="left" || border.side=="right") {

            //angle_old = Math.PI - angle_old   

            var angle_old = Math.atan2(-d_y, -d_x)

        }

        var direction_x_new = Math.cos(-angle_old)
        var direction_y_new = Math.sin(-angle_old)

        if (debug) {

            var check_x = Math.cos(angle_old)
            var check_y = Math.sin(angle_old)                   

            var angle_new = Math.atan2(direction_y_new, direction_x_new)
        }

        var x_y_prop = direction_x_new / direction_y_new
        var c_sq = dot.speed_per_loop * dot.speed_per_loop / ( (direction_x_new * direction_x_new) + 
                    ( (direction_x_new / x_y_prop) * (direction_x_new/x_y_prop) ) ) 
        var c = c_sq**(1/2)

        dot.course.x = round_calc_general(direction_x_new * c)
        dot.course.y = round_calc_general(direction_y_new * c)  

        return
    }

    function get_set_new_course_two_dots(dot_1, dot_2, incr) {

        if (debug_coll) {

            for (var cl=0;cl<debug_check_list.length;cl++) {

                var to_check = debug_check_list[cl]

                if (dot_1.id==to_check || dot_2.id==to_check) {

                    break
                }
            }
        }

        var dot_1_coll_x = dot_1.coords_theory["x"]
        var dot_1_coll_y = dot_1.coords_theory["y"]
        var dot_2_coll_x = dot_2.coords_theory["x"]
        var dot_2_coll_y = dot_2.coords_theory["y"]

        var x_diff = dot_2_coll_x - dot_1_coll_x 
        var y_diff = dot_2_coll_y - dot_1_coll_y                
        var angle_coll = Math.atan2(y_diff, x_diff)

        var angle_1 = Math.atan2(dot_1.course["y"], dot_1.course["x"])
        var angle_2 = Math.atan2(dot_2.course["y"], dot_2.course["x"])

        var vel_1 = dot_1.speed_per_loop
        var vel_2 = dot_2.speed_per_loop

        var mass_1 = Math.PI * Math.pow(dot_1.radius, 2)
        var mass_2 = Math.PI * Math.pow(dot_2.radius, 2)
        // var mass_1 = Math.PI * 400
        // var mass_2 = Math.PI * 400
        var mass_total = mass_1 + mass_2

        var equation_tail_end_1 = Math.cos(angle_coll+(Math.PI/2))
        var equation_tail_end_2 = Math.sin(angle_coll+(Math.PI/2))

        var counter_1_p1 = vel_1 * Math.cos(angle_1-angle_coll)*(mass_1-mass_2)
        var counter_1_p2 = 2*mass_2*vel_2*Math.cos(angle_2-angle_coll)
        var division_1 = (counter_1_p1+counter_1_p2) / mass_total 
        var equation_tail_middle_1 = vel_1*Math.sin(angle_1-angle_coll)
        var result_1_x = (division_1 * Math.cos(angle_coll)) + 
                            (equation_tail_middle_1*equation_tail_end_1)
        var result_1_y = (division_1 * Math.sin(angle_coll)) + 
                            (equation_tail_middle_1*equation_tail_end_2)

        var counter_2_p1 = vel_2 * Math.cos(angle_2-angle_coll)*(mass_2-mass_1)
        var counter_2_p2 = 2*mass_1*vel_1*Math.cos(angle_1-angle_coll)
        var division_2 = (counter_2_p1+counter_2_p2) / mass_total
        var equation_tail_middle_2 = vel_2*Math.sin(angle_2-angle_coll)
        var result_2_x = (division_2 * Math.cos(angle_coll)) + 
                            (equation_tail_middle_2*equation_tail_end_1)
        var result_2_y = (division_2 * Math.sin(angle_coll)) + 
                            (equation_tail_middle_2*equation_tail_end_2)

        dot_1.course["x"] = round_calc_general(result_1_x)
        dot_1.course["y"] = round_calc_general(result_1_y)
        dot_1.speed_per_loop = round_calc_general(Math.sqrt(Math.pow(result_1_x, 2) + 
                                Math.pow(result_1_y, 2)))
        dot_1.speed = round_calc_general(dot_1.speed_per_loop * (1/(main_loop_interval/1000)))

        dot_2.course["x"] = round_calc_general(result_2_x)
        dot_2.course["y"] = round_calc_general(result_2_y)
        dot_2.speed_per_loop = round_calc_general(Math.sqrt(Math.pow(result_2_x, 2) + 
                                Math.pow(result_2_y, 2)))
        dot_2.speed = round_calc_general(dot_2.speed_per_loop * (1/(main_loop_interval/1000)))

        return
    }

    function weave_dots_with_grid(grid_positions, dots) {

        for (var d=0;d<dots.length;d++) {

            grid_positions = weave_grids_together(grid_positions, dots[d].grid_spots)
        }

        return grid_positions
    }

    function grid_sort_positions(grid_positions) {
        // - insertion sort

        for (var i=1;i<grid_positions.length;i++) {

            for (var k=i;k>0;k--) {

                // next one is higher, swap
                if (grid_positions[k-1]["x"]>grid_positions[k]["x"]) {

                    swap_in_list(grid_positions, k, k-1)
                    continue
                }

                if (grid_positions[k-1]["x"]==grid_positions[k]["x"]) {

                    // next one has equal x, but higher y, swap
                    if (grid_positions[k-1]["y"]>grid_positions[k]["y"]) {

                        swap_in_list(grid_positions, k, k-1)
                        continue
                    }

                    // next one has equal x and equal or lower y, went far enough
                    break
                }

                // next x is lower, went far enough
                if (grid_positions[k-1]["x"]<grid_positions[k]["x"]) {

                    break
                }
            }
        }

        return
    }

    function weave_grids_together(grid_positions, dots_to_add) {
        //~ if not fast enough, a hash table will probably be the
        //  way to go.

        var new_grid_positions = new Array((grid_positions.length + dots_to_add.length))

        grid_positions.push({ 'type': 'mock', 'x': Infinity })
        dots_to_add.push({ 'type': 'mock', 'x': Infinity })

        var placing_spot = 0
        var spot_grid = 0
        var spot_dot = 0

        while (placing_spot<new_grid_positions.length) {

            if (grid_positions[spot_grid]['x']<dots_to_add[spot_dot]['x']) {

                new_grid_positions[placing_spot] = grid_positions[spot_grid]
                spot_grid++

            } else if (grid_positions[spot_grid]['x']>dots_to_add[spot_dot]['x']) {

                new_grid_positions[placing_spot] = dots_to_add[spot_dot]
                spot_dot++

            } else if (grid_positions[spot_grid]['x']==dots_to_add[spot_dot]['x']) {

                if (grid_positions[spot_grid]['y']<dots_to_add[spot_dot]['y']) {

                    new_grid_positions[placing_spot] = grid_positions[spot_grid]
                    spot_grid++

                } else {

                    new_grid_positions[placing_spot] = dots_to_add[spot_dot]
                    spot_dot++
                }
            }

            placing_spot++
        }

        return new_grid_positions
    }

    function sort_collision_time(collision_storage) {
        // insertion sort

        for (var i=1;i<collision_storage.length;i++) {

            for (var k=i;k>0;k--) {

                if (collision_storage[k-1]['incr']>collision_storage[k]['incr']) {

                    swap_in_list(collision_storage, k, k-1)
                    continue
                }

                break
            }
        }

        return
    }

    function swap_in_list(list, first, second) {
        var temp = list[first]
        list[first] = list[second]
        list[second] = temp
    }

    function get_set_border_objects(border_objects) {

        var border_object_1 = { type: "line", start: { x: 1, y: 1 }, 
                                                end: { x: 1, y: 500 },
                                                side: "left",
                               }
        var border_object_2 = { type: "line", start: { x: 1, y: 500 },
                                                end: { x: 500, y: 500 },
                                                side: "ceiling",
                               }
        var border_object_3 = { type: "line", start: { x: 500, y: 500 }, 
                                                end: { x: 500, y: 1 },
                                                side: "right",
                               }
        var border_object_4 = { type: "line", start: { x: 500, y: 1 }, 
                                                end: { x: 1, y: 1 },
                                                side: "bottom",
                               }

        border_objects.push(border_object_1)
        border_objects.push(border_object_2)
        border_objects.push(border_object_3)
        border_objects.push(border_object_4)

        return
    }

    function set_border_positions(grid_border_positions, border_objects) {
        get_grid_line_1(grid_border_positions, border_objects[0])
        get_grid_line_2(grid_border_positions, border_objects[1])
        get_grid_line_1(grid_border_positions, border_objects[2])
        get_grid_line_2(grid_border_positions, border_objects[3])

        return
    }

    function get_grid_line_1(grid_border_positions, line_object) {

        if (line_object.start.x<line_object.end.x) {

            var start = line_object.start
            var end = line_object.end

        } else if (line_object.start.x>line_object.end.x) {

            var start = line_object.end
            var end = line_object.start

        } else if (line_object.start.x==line_object.end.x) {

            if (line_object.start.y<line_object.end.y) {

                var start = line_object.start
                var end = line_object.end

            } else {

                var start = line_object.end
                var end = line_object.start
            }
        }

        var options = { left: 1, 
                        right: Math.ceil(end.x/section_size.x)
                       }

        var grid_start = Math.ceil(start.y/section_size.y)
        var grid_end = Math.ceil(end.y/section_size.y)

        for (var gr=grid_start;gr<=grid_end;gr++) {

            grid_border_positions.push({ type: "line",
                                         obj: line_object,
                                         x: options[line_object.side],
                                         y: gr
                                        })
        }

        return
    }

    function get_grid_line_2(grid_border_positions, line_object) {

        if (line_object.start.x<line_object.end.x) {

            var start = line_object.start
            var end = line_object.end

        } else if (line_object.start.x>line_object.end.x) {

            var start = line_object.end
            var end = line_object.start

        } else if (line_object.start.x==line_object.end.x) {

            if (line_object.start.y<line_object.end.y) {

                var start = line_object.start
                var end = line_object.end

            } else {

                var start = line_object.end
                var end = line_object.start
            }

        }

        var options = {bottom: 1, ceiling: Math.ceil(500/section_size.y)}   
        var grid_start = Math.ceil(start.x/section_size.x)
        var grid_end = Math.ceil(end.x/section_size.x)

        for (var gr=grid_start;gr<=grid_end;gr++) {

            grid_border_positions.push({ type: "line",
                                         obj: line_object,
                                         x: gr,
                                         y: options[line_object.side]
                                        })
        }       
        return
    }

    class Dot {
        constructor(id, dot_spot) {

            // logistical information
            this.id = id
            this.dot_spot = dot_spot 
            this.grid_spots = []
            this.next_coords_theory = {} 
            this.increment = 0                  // 0 means hasn't moved yet this loop
            // dot shape information
            this.radius = 20

            // course information
            this.course = []
            this.speed = undefined              // in pixels/second
            this.speed_per_loop = undefined     // in pixels/loop
            this.coords = {}
            this.coords_theory = {}

            this.set_speed()
            this.set_course()
            this.create_dot()
        }

        set_speed() {
            this.speed = 552

            if (debug_coll) {
                if (this.id==1) {
                    this.speed = 925
                } else if (this.id==2) {
                    this.speed = 660
                } else if (this.id==3) {
                    this.speed = 360
                } else if (this.id==4) {
                    this.speed = 683
                } else if (this.id==5) {
                    this.speed=1500
                } else if (this.id==6) {
                    this.speed = 1500
                }
            }

            this.speed_per_loop = round_calc_general(this.speed/(1/(main_loop_interval/1000)))
            return
        }

        set_course() {
            // var x = Math.random()
            // var y = Math.random()

            var x = .5
            var y = .6

            if (debug_coll) {
                if (this.id==1) {
                    var x = .8
                    var y = .2
                } else if (this.id==2) {
                    var x = .79
                    var y = .30
                } else if (this.id==3) {
                    var x = .6
                    var y = .77
                } else if (this.id==4) {
                    var x = .5
                    var y = .6
                } else if (this.id==5) {
                    var x = .5
                    var y = .65
                } else if (this.id==6) {
                    var x = .8
                    var y = .203
                }
            }

            this.course = this.convert_course(x, y)
            this.coords_theory = { x: round_calc_general(this.course["x"]+starting_point.x), 
                                   y: round_calc_general(this.course["y"]+starting_point.y)
                                  }
            this.coords = { x: Math.round(this.coords_theory["x"]), 
                            y: Math.round(this.coords_theory["y"]),
                           }

            if (debug_specific) {

                if (this.id==1) {

                    this.course = {x: 19.4562063, y: 0.77704052}
                    this.coords_theory = {x: 462.75462212, y: 475.56497464}
                    this.coords = {x: Math.round(this.coords_theory["x"]), 
                                   y: Math.round(this.coords_theory["y"])}
                    this.increment = 0.036 
                    this.speed_per_loop = 19.47171681

                } else if (this.id==2) {

                    this.course = {x: 36.30442919, y: 55.09223259}
                    this.coords_theory = {x: 422.03802785, y: 454.94685177}
                    this.coords = {x: Math.round(this.coords_theory["x"]), 
                                   y: Math.round(this.coords_theory["y"])}
                    this.increment = 0.426
                    this.speed_per_loop = 65.97852431
                }
            }

            return
        }

        convert_course(x, y) {
            var c_sq = Math.pow(this.speed_per_loop, 2) / (Math.pow(x, 2) + Math.pow(y, 2))
            var c = round_calc_general(Math.sqrt(c_sq))

            return {x: round_calc_general(c*x), y: round_calc_general(c*y)}
        }

        create_dot() {
            var canvass = this.create_canvas()                  
            var drawing  = canvass.getContext("2d")

            drawing.beginPath()
            drawing.arc(this.radius,this.radius,this.radius,0,2*Math.PI)
            drawing.fillStyle = "#000000"

            if (debug) {
                if (this.id==3) {
                    drawing.fillStyle = "#AA0000"
                }
            }

            if (demo_mode) {
                if (this.id==3) {
                    drawing.fillStyle = "#AA0000"   
                }
                if (this.id==4) {
                    drawing.fillStyle = "#00AA00"   
                }
                if (this.id==5) {
                    drawing.fillStyle = "#0000AA"   
                }
            }

            drawing.fill()

            if (debug_add_numbers) {

                var txt = this.id.toString()
                drawing.fillStyle = "red"   
                drawing.font = "bold 16px Arial"
                drawing.fillText(txt, this.radius, this.radius)
            }


            return
        }

        create_canvas() {
            var center = this.radius
            var dot_canvas = document.createElement('canvas')

            dot_canvas.id = "dot_" + this.id
            dot_canvas.className = "dot_holder"
            dot_canvas.style.position = "absolute";
            dot_canvas.style.text = this.id
            dot_canvas.style.margin = -(center) + "px", 0, 0, -(center) + "px"
            dot_canvas.style.left = this.coords["x"] + "px"
            dot_canvas.style.top = this.coords["y"] + "px"

            dot_canvas.width = center*2
            dot_canvas.height = center*2

            document.getElementById("circle").appendChild(dot_canvas)

            return dot_canvas
        }

        move() {
            var dot_canvas = document.getElementById("dot_" + this.id)  
            dot_canvas.style.left = this.coords["x"] + "px"
            dot_canvas.style.top = this.coords["y"] + "px"

            if (debug_showstoppers) {

                debug_check_dots_going_outside(this)
            }

            return
        }

        set_coords() {
            this.coords_theory["x"] = this.next_coords_theory["x"] 
            this.coords_theory["y"] = this.next_coords_theory["y"]
            this.coords["x"] = Math.round(this.coords_theory["x"])
            this.coords["y"] = Math.round(this.coords_theory["y"])

            return
        }

        determine_next_coords() {
            this.next_coords_theory["x"] = round_calc_general(this.coords_theory["x"] + 
                                            this.course["x"])
            this.next_coords_theory["y"] = round_calc_general(this.coords_theory["y"] + 
                                            this.course["y"])

            return
        }

        manage_sections_setting() {

            this.grid_spots = []

            // start situation
            this.get_set_section(this.coords_theory)

            // for end situation
            this.get_set_section(this.next_coords_theory)

            // get square in grid from minimum and maximum 
            // position in start and end situation
            this.determine_all_sections()   

            return
        }

        determine_all_sections() {
            var x_min = Infinity 
            var y_min = Infinity
            var x_max = -Infinity
            var y_max = -Infinity

            for (var p=0;p<this.grid_spots.length;p++) {

                if (this.grid_spots[p]["x"]<x_min) {

                    x_min = this.grid_spots[p]["x"] 
                }

                if (this.grid_spots[p]["x"]>x_max) {

                    x_max = this.grid_spots[p]["x"]
                }

                if (this.grid_spots[p]["y"]<y_min) {

                    y_min = this.grid_spots[p]["y"] 
                }

                if (this.grid_spots[p]["y"]>y_max) {

                    y_max = this.grid_spots[p]["y"]
                }
            }

            // this list is cleared and than reused                 
            this.grid_spots = []

            // other algos rely on this being sorted
            for (var x=x_min;x<=x_max;x++) {

                for (var y=y_min;y<=y_max;y++) {

                    this.grid_spots.push({ type: "dot",
                                           obj: this, 
                                           x: x, 
                                           y: y,
                                          })
                }
            }

            return
        }

        get_set_section(coords) {

            this.grid_spots.push(this.calc_section(coords["x"], 
                                                   coords["y"]))

            var pi_steps = (2*Math.PI) / circle_resolution
            for (var c_res=0;c_res<circle_resolution;c_res++) {

                // "ce" stands for circle edge
                var x_ce = Math.cos(pi_steps*c_res) * this.radius
                var y_ce = Math.sin(pi_steps*c_res) * this.radius

                var grid_section_next = this.calc_section(coords["x"] + x_ce, 
                                                          coords["y"] + y_ce)

                if (this.check_validity_section(grid_section_next)) {

                    this.grid_spots.push(grid_section_next)
                }
            }

            return
        }

        calc_section(coord_x, coord_y) {
        // not incorporated what to do if dot is already
        // outside of the outer boundaries

            var section_x = coord_x / section_size["x"]
            var section_y = coord_y / section_size["y"]
            var grid_section_x = Math.floor(section_x+1)
            var grid_section_y = Math.floor(section_y+1)

            return { x: grid_section_x, 
                     y: grid_section_y,
                    }
        }

        check_validity_section(grid_section) {
            // - Cleans the data
            // - Creates a smaller grid_positions 
            //   array to work with.
            //~- May create problems when field is
            //   not a square anymore. Because what
            //   would be the outer boundaries?

            if (grid_section.x < outer_boundaries.x[0]) {

                return false
            }

            if (grid_section.x > outer_boundaries.x[1]) {

                return false
            }

            if (grid_section.y < outer_boundaries.y[0]) {

                return false
            }

            if (grid_section.y > outer_boundaries.y[1]) {

                return false
            }

            return true
        }


    } // end Dot class

    function set_outer_boundaries(outer_boundaries, border_objects) {
        //~ obviously could use some refactoring

        var xmin = Infinity
        var xmax = -Infinity
        var ymin = Infinity
        var ymax = -Infinity

        var bos = border_objects

        for (var bo=0; bo<bos.length; bo++) {

            if (bos[bo].start.x < xmin) {
                xmin = bos[bo].start.x
            }

            if (bos[bo].end.x < xmin) {
                xmin = bos[bo].start.x
            }

            if (bos[bo].start.y < ymin) {
                ymin = bos[bo].start.y
            }

            if (bos[bo].end.y < ymin) {
                ymin = bos[bo].start.y
            }


            if (bos[bo].start.x > xmax) {
                xmax = bos[bo].start.x
            }

            if (bos[bo].end.x > xmax) {
                xmax = bos[bo].start.x
            }

            if (bos[bo].start.y > ymax) {
                ymax = bos[bo].start.y
            }

            if (bos[bo].end.y > ymax) {
                ymax = bos[bo].start.y
            }
        }

        outer_boundaries['x'] = [xmin, xmax]
        outer_boundaries['y'] = [ymin, ymax]
    }


    function debug_check_dots_going_outside(dot) {

        if (dot.coords.x>500-dot.radius 
         || dot.coords.y>500-dot.radius
         || dot.coords.x<0+dot.radius 
         || dot.coords.y<0+dot.radius) {
            console.log(dot.coords.x + " | " + dot.coords.y)
            alert("stuff has gone done:\n\n" +
                  "        dot is going outside of border")
            debugger
        }
        return
    }

    function debug_test_overlap_all_dots(dots) {

        if (dots.length<settings_maximum_dots) {

            return
        }

        for(var d=0;d<dots.length-1;d++) {

            for(var dd=d+1;dd<dots.length;dd++) {

                var dx = (dots[dd].coords_theory.x - dots[d].coords_theory.x)**2
                var dy = (dots[dd].coords_theory.y - dots[d].coords_theory.y)**2
                var dist = (dx+dy)**(1/2)
                var dist_norm = dots[d].radius + dots[dd].radius

                if (dist<(dist_norm*.95)) {

                    alert("stuff has gone down:\n\n" +
                          "        significant overlap of dots")
                    debugger
                }
            }
        }

        return
    }

    function debug_check_overlap(dot_1, dot_2) {

        if (dot_1 instanceof Dot && dot_2 instanceof Dot) {

            var dx = round_calc_general(dot_1.coords_theory.x - dot_2.coords_theory.x)
            var dy = round_calc_general(dot_1.coords_theory.y - dot_2.coords_theory.y)
            var c = round_calc_general((round_calc_general(dx**2) + 
                        round_calc_general(dy**2))**(1/2))

            var min_distance = round_calc_general(dot_1.radius + dot_2.radius)

            if (c<(min_distance)) {

            }
        }

        return
    }

    function debug_test_find_collision () {
        // NOTE: for debug mode

        var dot_1 = { coords_theory: {}, course: {} }   
        var dot_2 = { coords_theory: {}, course: {} }   

        dot_1.coords_theory.x = 0
        dot_1.coords_theory.y = 4   
        dot_1.course.x = 1
        dot_1.course.y = -(1/3) 
        dot_1.radius = 0.5
        dot_1.increment = 0

        dot_2.coords_theory.x = 0
        dot_2.coords_theory.y = -1  
        dot_2.course.x = 1
        dot_2.course.y = 1
        dot_2.radius = 0.5
        dot_2.increment = 0

        find_collision_dots_5(dot_1, dot_2)

        dot_1.coords_theory.x = 1
        dot_1.coords_theory.y = 4   
        dot_1.course.x = 4
        dot_1.course.y = 2 
        dot_1.radius = 0.5
        dot_1.increment = 0

        dot_2.coords_theory.x = 3.5
        dot_2.coords_theory.y = 1   
        dot_2.course.x = -1
        dot_2.course.y = 6
        dot_2.radius = 0.5
        dot_2.increment = 0

        find_collision_dots_5(dot_1, dot_2)

        dot_1.coords_theory.x = 1
        dot_1.coords_theory.y = 6   
        dot_1.course.x = 4
        dot_1.course.y = -2 
        dot_1.radius = 0.5
        dot_1.increment = 0

        dot_2.coords_theory.x = 2.5 
        dot_2.coords_theory.y = 1   
        dot_2.course.x = 1
        dot_2.course.y = 6
        dot_2.radius = 0.5
        dot_2.increment = 0

        find_collision_dots_5(dot_1, dot_2)
    }

</script>

<div id="together">
    <div id="circle"></div>
    <span>Number of dots:&nbsp;
        <span id="counter_dots" style="bottom:0; color:red;">0</span>
    </span>
</div>

<script>

    var el = document.getElementById("together")

    var ref_point = document.getElementsByClassName("ref_point")[0]
    ref_point.parentNode.insertBefore(el, null)

</script>
            </div>
            <!-- /.entry-content -->
    <hr/>
    <section class="comments" id="comments">
        <h2>Comments</h2>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'site-ceilings'; // required: replace example with your forum shortname

            var disqus_config = function () {
                this.language = "en";

                        this.page.identifier = '2019-02-14-projects-flying-dots';
                        this.page.url = 'http://localhost:8000/projects-flying-dots.html';
            };

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function () {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
            Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    </section>
        </article>
    </section>

        </div>
        <div class="col-sm-3" id="sidebar">
            <aside>
<!-- Sidebar -->
<section class="well well-sm">
  <ul class="list-group list-group-flush">

<!-- Sidebar/Social -->
<li class="list-group-item">
  <h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Social</span></h4>
  <ul class="list-group" id="social">
    <li class="list-group-item"><a href="https://github.com/dzet"><i class="fa fa-github-square fa-lg"></i> Github</a></li>
    <li class="list-group-item"><a href="https://www.linkedin.com/in/denniszethof"><i class="fa fa-linkedin-square fa-lg"></i> LinkedIn</a></li>
    <li class="list-group-item"><a href="https://www.happycow.net/members/profile/DZet/"><i class="fa fa-happycow-square fa-lg"></i> Happycow</a></li>
    <li class="list-group-item"><a href="http://www.dennisenroben.nl"><i class="fa fa-dennis&roben-square fa-lg"></i> Dennis&Roben</a></li>
  </ul>
</li>
<!-- End Sidebar/Social -->
  </ul>
</section>
<!-- End Sidebar -->            </aside>
        </div>
    </div>
</div>
<!-- End Content Container -->

<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2019 Dennis Zethof
            &middot; Powered by <a href="https://github.com/getpelican/pelican-themes/tree/master/pelican-bootstrap3" target="_blank">Pelican-Bootstrap3</a>,
            <a href="https://daringfireball.net/projects/markdown/" target="_blank">Markdown</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://localhost:8000/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="http://localhost:8000/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="http://localhost:8000/theme/js/respond.min.js"></script>


    <!-- Disqus -->
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'site-ceilings'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
            var s = document.createElement('script');
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>
    <!-- End Disqus Code -->


</body>
</html>